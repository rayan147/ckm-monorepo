// This is your a schema file,
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

generator zod {
  provider               = "zod-prisma-types"
  output                 = "../src/generated/zod" // Goes to zod-schemas
  createInputTypes       = true
  createModelTypes       = true
  addInputTypeValidation = true
  addIncludeType         = true
  addSelectType          = true
  modelPrefix            = "Zod"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Recipe Nutrition Information
model RecipeNutrition {
  id                Int     @id @default(autoincrement())
  recipeId          Int     @unique
  recipe            Recipe  @relation(fields: [recipeId], references: [id])
  servingSize       Float
  servingUnit       String
  calories          Float
  protein           Float
  carbohydrates     Float
  fat               Float
  fiber             Float
  sugar             Float
  sodium            Float
  // Allergen indicators 
  containsGluten    Boolean @default(false)
  containsDairy     Boolean @default(false)
  containsNuts      Boolean @default(false)
  containsEggs      Boolean @default(false)
  containsSoy       Boolean @default(false)
  containsFish      Boolean @default(false)
  containsShellfish Boolean @default(false)
  containsSesame    Boolean @default(false)

  @@map("recipeNutrition")
}

// Recipe Critical Control Points
model RecipeCriticalPoint {
  id          Int      @id @default(autoincrement())
  recipeId    Int
  recipe      Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  stepNumber  Int
  description String
  threshold   Float?
  unit        String?
  action      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("recipeCriticalPoint")
}

// Recipe Storage Instructions
model RecipeStorage {
  id            Int      @id @default(autoincrement())
  recipeId      Int      @unique
  recipe        Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  temperature   Float?
  method        String
  shelfLife     Int // in hours
  containerType String?
  specialNotes  String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("recipeStorage")
}

// Recipe Photos
model RecipePhoto {
  id          Int       @id @default(autoincrement())
  recipeId    Int
  recipe      Recipe    @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  url         String
  type        PhotoType
  stepNumber  Int? // For step-by-step photos
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("recipePhoto")
}

// Recipe Temperature Control Points
model RecipeTemperature {
  id          Int      @id @default(autoincrement())
  recipeId    Int
  recipe      Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  stepNumber  Int // Corresponds to RecipeInstruction stepNumber
  minTemp     Float
  maxTemp     Float
  isCritical  Boolean  @default(false)
  holdTime    Int? // Times in mins 
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("recipeTemperature")
}

// Recipe Costs and Yields
model RecipeYield {
  id             Int      @id @default(autoincrement())
  recipeId       Int
  recipe         Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  expectedYield  Float
  actualYield    Float?
  unit           String
  wastagePercent Float?
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("recipeYield")
}

// Recipe Labor Cost
model RecipeLaborCost {
  id             Int      @id @default(autoincrement())
  recipeId       Int
  recipe         Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  prepTime       Int // minutes
  cookTime       Int // minutes
  laborRate      Float // per hour
  totalLaborCost Float
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("recipeLaborCost")
}

// Integrating POS Data
// Purpose: to store sales data  from the POS system for accurate calculations,
// insights, and add inventory adjustments

model SalesTransactions {
  id               Int        @id @default(autoincrement())
  posTransactionID String?    @unique
  restaurantId     Int
  restaurant       Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Restrict)
  menuItemId       Int
  menuItem         MenuItem   @relation(fields: [menuItemId], references: [id], onDelete: Restrict)
  price            Float
  total            Float
  transactionDate  DateTime
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@map("salesTransactions")
}

enum ChecklistItemType {
  BOOLEAN // Yes/No questions
  NUMERIC // Number values (like temperatures)
  TEXT // Written responses
  TEMPERATURE // Specifically for temperature checks
  PHOTO // Required photo documentation
}

// Menu Organization
model MenuCategory {
  id           Int        @id @default(autoincrement())
  name         String
  description  String?
  displayOrder Int // For ordering categories in the menu
  menuId       Int
  menu         Menu       @relation(fields: [menuId], references: [id], onDelete: Cascade)
  menuItems    MenuItem[]
  isActive     Boolean    @default(true)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([menuId, name])
  @@map("menuCategory")
}

model RecipeVersion {
  id            Int                 @id @default(autoincrement())
  recipeId      Int
  recipe        Recipe              @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  versionNumber Int
  description   String?
  changes       String? // Description of changes from previous version
  ingredients   RecipeIngredient[]
  instructions  RecipeInstruction[]
  isActive      Boolean             @default(false)
  createdById   Int
  createdBy     User                @relation(fields: [createdById], references: [id], onDelete: Restrict)
  approvedById  Int?
  approvedBy    User?               @relation("RecipeApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedAt    DateTime?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@unique([recipeId, versionNumber])
  @@map("recipeVersion")
}

// Equipment Management
model Equipment {
  id              Int               @id @default(autoincrement())
  name            String
  description     String?
  model           String?
  serialNumber    String?
  purchaseDate    DateTime?
  lastMaintenance DateTime?
  nextMaintenance DateTime?
  status          EquipmentStatus   @default(ACTIVE)
  location        String?
  restaurantId    Int
  restaurant      Restaurant        @relation(fields: [restaurantId], references: [id], onDelete: Restrict)
  recipes         RecipeEquipment[]
  maintenanceLogs MaintenanceLog[]
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@map("equipment")
}

model RecipeEquipment {
  id                  Int                @id @default(autoincrement())
  recipeId            Int
  recipe              Recipe             @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  equipmentId         Int
  equipment           Equipment          @relation(fields: [equipmentId], references: [id], onDelete: Restrict)
  notes               String?
  RecipeInstruction   RecipeInstruction? @relation(fields: [recipeInstructionId], references: [id], onDelete: SetNull)
  recipeInstructionId Int?

  @@unique([recipeId, equipmentId])
  @@map("recipeEquipment")
}

model MaintenanceLog {
  id          Int             @id @default(autoincrement())
  equipmentId Int
  equipment   Equipment       @relation(fields: [equipmentId], references: [id])
  date        DateTime        @default(now())
  type        MaintenanceType
  description String
  cost        Float?
  performedBy String
  notes       String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@map("maintenanceLog")
}

// Quality Control
model QualityChecklist {
  id           Int                 @id @default(autoincrement())
  name         String
  description  String?
  restaurantId Int
  restaurant   Restaurant          @relation(fields: [restaurantId], references: [id], onDelete: Restrict)
  items        ChecklistItem[]
  completions  ChecklistComplete[]
  frequency    ChecklistFrequency  @default(DAILY)
  isActive     Boolean             @default(true)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt

  @@map("qualityChecklist")
}

model ChecklistItem {
  id             Int                     @id @default(autoincrement())
  checklistId    Int
  checklist      QualityChecklist        @relation(fields: [checklistId], references: [id], onDelete: Cascade)
  description    String
  order          Int
  type           ChecklistItemType
  requiredPhotos Boolean                 @default(false)
  completions    ChecklistItemComplete[]
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt

  @@map("checklistItem")
}

model ChecklistComplete {
  id            Int                     @id @default(autoincrement())
  checklistId   Int
  checklist     QualityChecklist        @relation(fields: [checklistId], references: [id], onDelete: Cascade)
  completedById Int
  completedBy   User                    @relation(fields: [completedById], references: [id], onDelete: Restrict)
  date          DateTime
  items         ChecklistItemComplete[]
  notes         String?
  createdAt     DateTime                @default(now())
  updatedAt     DateTime                @updatedAt

  @@map("checklistComplete")
}

model ChecklistItemComplete {
  id                  Int               @id @default(autoincrement())
  checklistCompleteId Int
  checklistComplete   ChecklistComplete @relation(fields: [checklistCompleteId], references: [id], onDelete: Cascade)
  checklistItemId     Int
  checklistItem       ChecklistItem     @relation(fields: [checklistItemId], references: [id], onDelete: Cascade)
  status              ChecklistStatus
  notes               String?
  photoUrls           String[]
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@map("checklistItemComplete")
}

// Supplier Price Tracking
model SupplierPriceHistory {
  id           Int        @id @default(autoincrement())
  vendorId     Int
  vendor       Vendor     @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  ingredientId Int
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Restrict)
  price        Float
  unit         String
  startDate    DateTime
  endDate      DateTime?
  notes        String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@map("supplierPriceHistory")
}

// Customer Feedback
model CustomerFeedback {
  id            Int            @id @default(autoincrement())
  restaurantId  Int
  restaurant    Restaurant     @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  menuItemId    Int?
  menuItem      MenuItem?      @relation(fields: [menuItemId], references: [id], onDelete: Restrict)
  rating        Int // 1-5 rating
  comment       String?
  source        FeedbackSource
  tags          String[] // Array of feedback categories/tags
  status        FeedbackStatus @default(NEW)
  responseText  String?
  respondedAt   DateTime?
  respondedById Int?
  respondedBy   User?          @relation(fields: [respondedById], references: [id], onDelete: SetNull)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@map("customerFeedback")
}

// Dietary Restrictions
model DietaryRestriction {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  description String?
  icon        String?
  menuItems   MenuItem[]
  recipes     Recipe[]
  ingredients Ingredient[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@map("dietaryRestriction")
}

// Additional Enums
enum EquipmentStatus {
  ACTIVE
  MAINTENANCE
  REPAIR
  RETIRED
}

enum MaintenanceType {
  ROUTINE
  REPAIR
  INSPECTION
  CLEANING
  CALIBRATION
}

enum ChecklistFrequency {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  CUSTOM
}

enum ChecklistStatus {
  COMPLETED
  FAILED
  SKIPPED
  NEEDS_ATTENTION
}

enum FeedbackSource {
  IN_PERSON
  ONLINE
  MOBILE_APP
  THIRD_PARTY
}

enum FeedbackStatus {
  NEW
  IN_PROGRESS
  RESPONDED
  CLOSED
  FLAGGED
}

// Recipe Organization and Versioning
model RecipeTag {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  recipes     Recipe[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("recipeTag")
}

// Sales and Leftovers Tracking
//Purpose: to track Leftovers after service for waste managment and cost optimization

model LeftoverItem {
  id           Int        @id @default(autoincrement())
  restaurantId Int
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  date         DateTime
  menuItemId   Int
  menuItem     MenuItem   @relation(fields: [menuItemId], references: [id], onDelete: Restrict)
  quantity     Int
  reason       String
  recordedById Int
  recordedBy   User       @relation(fields: [recordedById], references: [id], onDelete: Restrict)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@map("leftoverItem")
}

//  Waste Tracking
//  Purpose: To record and analyze waste for inventory management and cost reduction.

model WasteRecord {
  id           Int        @id @default(autoincrement())
  restaurantId Int
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  date         DateTime
  ingredientId Int
  ingrediente  Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Restrict)
  quantity     Float
  unit         String
  reason       String
  recordedById Int
  recordedBy   User       @relation(fields: [recordedById], references: [id])
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@map("wasteRecord")
}

// schema.prisma
enum ProductionStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  HAS_NOT_START // Make sure this matches exactly
}

//Production Sheets
//Purpose: To plan and manage daily production tasks.

model ProductionPlan {
  id           Int                  @id @default(autoincrement())
  restaurantId Int
  restaurant   Restaurant           @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  date         DateTime
  status       ProductionStatus     @default(HAS_NOT_START)
  createdById  Int
  createdBy    User                 @relation(fields: [createdById], references: [id], onDelete: Restrict)
  items        ProductionPlanItem[]
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  @@map("productionPlan")
}

model ProductionPlanItem {
  id               Int            @id @default(autoincrement())
  productionPlanId Int
  productionPlan   ProductionPlan @relation(fields: [productionPlanId], references: [id], onDelete: Cascade)
  recipeId         Int
  recipe           Recipe         @relation(fields: [recipeId], references: [id], onDelete: Restrict)
  quantity         Int
  unit             String
  assignedToId     Int?
  assignedTo       User?          @relation(fields: [assignedToId], references: [id], onDelete: SetNull)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@map("productionPlanItem")
}

//Time Tracking and Productivity Analysis
//Purpose: To track tasks during shifts for productivity analysis.
model ShiftTask {
  id        Int      @id @default(autoincrement())
  shiftId   Int
  shift     Shift    @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  taskType  TaskType
  startTime DateTime
  endTime   DateTime
  duration  Int // duration in minutes
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("shiftTask")
}

enum TaskType {
  PREP
  COOKING
  CLEANING
  INVENTORY
  OTHER
}

//AI-Driven Scheduling
//Purpose: To manage staff availability and scheduling constraints for smart scheduling.

model Availability {
  id        Int       @id @default(autoincrement())
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  dayOfWeek DayOfWeek
  startTime DateTime
  endTime   DateTime
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@map("availability")
}

model SchedulingConstraint {
  id              Int            @id @default(autoincrement())
  userId          Int
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  date            DateTime
  constraintsType ConstraintType
  startTime       DateTime
  endTime         DateTime
  notes           String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@map("schedulingConstraint")
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum ConstraintType {
  UNAVAILABLE
  PREFERRED
}

//Inventory Withdrawals
//Purpose: To record inventory usage for accurate stock levels

model InventoryWithdrawal {
  id              Int           @id @default(autoincrement())
  inventoryItemId Int
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  dateTime        DateTime
  quantity        Float
  unit            String
  recipeId        Int?
  recipe          Recipe?       @relation(fields: [recipeId], references: [id], onDelete: SetNull)
  createdById     Int
  createdBy       User          @relation(fields: [createdById], references: [id], onDelete: Restrict)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@map("inventoryWithdrawal")
}

//Allergen Information
//Purpose: To manage allergen data for ingredients and recipes.

model Allergen {
  id          Int                  @id @default(autoincrement())
  name        String               @unique
  description String?
  ingredients IngredientAllergen[]

  @@map("allergen")
}

model IngredientAllergen {
  id           Int        @id @default(autoincrement())
  ingredientId Int
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  allergenId   Int
  allergen     Allergen   @relation(fields: [allergenId], references: [id], onDelete: Cascade)

  @@unique([ingredientId, allergenId])
  @@map("ingredientAllergen")
}

//Nutritional Recommendations
//Purpose: To store recommendations based on nutritional analysis.
model NutritionalRecommendation {
  id             Int      @id @default(autoincrement())
  menuItemId     Int
  menuItem       MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  recommendation String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("nutritionalRecommendation")
}

model EarlyAccess {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  isEmailSent Boolean
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("earlyAccess")
}

model Organization {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  imageUrl    String?
  restaurants Restaurant[]
  users       User[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@map("organization")
}

model Inventory {
  id           Int           @id @default(autoincrement())
  restaurantId Int           @unique
  name         String? // Optional name for multiple inventory locations
  type         InventoryType @default(MAIN)
  isActive     Boolean       @default(true)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Relationships
  restaurant   Restaurant             @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  items        InventoryItem[]
  transactions InventoryTransaction[]
  stockCounts  StockCount[]

  // Constraints and indexes
  @@index([restaurantId, isActive])
  @@map("inventory")
}

model Restaurant {
  id                Int                 @id @default(autoincrement())
  name              String
  imageUrl          String?
  address           String
  city              String
  zipCode           String
  state             String
  owner             String
  organizationId    Int?
  organization      Organization?       @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  users             User[]
  cookbooks         CookBook[]
  inventory         Inventory?
  orders            Order[]
  foodCost          Float?
  recipes           Recipe[]
  menus             Menu[]
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  isDeleted         Boolean             @default(false)
  deleted           DateTime?
  salesTransactions SalesTransactions[]
  leftoverItems     LeftoverItem[]
  wasteRecords      WasteRecord[]
  productionPlans   ProductionPlan[]
  equipments        Equipment[]
  qualityChecklists QualityChecklist[]
  customerFeedbacks CustomerFeedback[]

  @@index([name])
  @@map("restaurant")
}

model User {
  id                        Int                    @id @default(autoincrement())
  email                     String                 @unique
  sub                       Int?                   @unique
  firstName                 String
  lastName                  String
  profileImage              String?
  organizationId            Int?
  organization              Organization?          @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  restaurantId              Int?
  restaurant                Restaurant?            @relation(fields: [restaurantId], references: [id], onDelete: SetNull)
  shifts                    Shift[]
  prepItems                 PrepItem[]
  inventoryUpdates          InventoryItem[]        @relation("InventoryItemUpdater")
  sessions                  Session[]
  passwordResets            PasswordReset[]
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  leftoverItems             LeftoverItem[]
  wasteRecords              WasteRecord[]
  productionPlans           ProductionPlan[]
  productionPlanItems       ProductionPlanItem[]
  availability              Availability[]
  schedulingConstraints     SchedulingConstraint[]
  inventoryWithdrawals      InventoryWithdrawal[]
  checklistCompletes        ChecklistComplete[]
  customerFeedbackResponses CustomerFeedback[]
  recipeVersionsCreated     RecipeVersion[]
  recipeVersionsApproved    RecipeVersion[]        @relation("RecipeApprover")
  InventoryTransactions     InventoryTransaction[]
  StockCounts               StockCount[]
  auth                      Auth[]

  @@index([email])
  @@index([firstName, lastName])
  @@map("user")
}

model Auth {
  id           String   @id @default(uuid())
  userId       Int      @unique()
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  passwordHash String
  role         UserRole @default(STAFF)

  @@map("auth")
}

model Session {
  id               String   @id @default(uuid())
  userId           Int
  verificationCode String   @unique
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token            String   @unique
  verified         Boolean  @default(false)
  expiresAt        DateTime
  createdAt        DateTime @default(now())

  @@index([token, verificationCode])
  @@map("session")
}

model CookBook {
  id           Int         @id @default(autoincrement())
  name         String
  imageUrl     String?
  category     String
  recipes      Recipe[]
  restaurantId Int?
  restaurant   Restaurant? @relation(fields: [restaurantId], references: [id], onDelete: SetNull)

  @@index([name])
  @@map("cookbook")
}

// Improve Recipe model relationships and indexing
model Recipe {
  id           Int        @id @default(autoincrement())
  name         String     @unique
  imageUrls    String[] // Changed from imageUrl for clarity
  description  String?
  servings     Int
  cookTime     Int
  prepTime     Int
  frequency    Int?
  restaurantId Int
  cookBookId   Int
  foodCost     Float?
  isDeleted    Boolean    @default(false)
  isPublished  Boolean    @default(false)
  publishedAt  DateTime?
  language     String     @default("en")
  skillLevel   SkillLevel @default(INTERMEDIATE)
  category     Category   @default(MAIN_COURSE)

  // Relationships with proper cascading
  restaurant          Restaurant            @relation(fields: [restaurantId], references: [id], onDelete: Restrict)
  cookBook            CookBook              @relation(fields: [cookBookId], references: [id], onDelete: Restrict)
  ingredients         RecipeIngredient[]
  instructions        RecipeInstruction[]
  menuItems           MenuItem[]
  foodCostHistory     FoodCostHistory[]
  prepHistory         PrepHistory[]
  prepBoards          PrepBoard[]
  prepItems           PrepItem[]
  menuItemRecipes     MenuItemRecipe[]
  productionPlanItems ProductionPlanItem[]
  withdrawals         InventoryWithdrawal[]
  tags                RecipeTag[]
  versions            RecipeVersion[]
  equipments          RecipeEquipment[]
  dietaryRestrictions DietaryRestriction[]
  temperatures        RecipeTemperature[]
  yields              RecipeYield[]
  laborCosts          RecipeLaborCost[]
  nutritionalInfo     RecipeNutrition?
  criticalPoints      RecipeCriticalPoint[]
  storage             RecipeStorage?
  photos              RecipePhoto[]
  recipeStats         RecipeStats?

  // Improved indexing
  @@index([restaurantId, isDeleted])
  @@index([cookBookId, isDeleted])
  @@index([name, isDeleted])
  @@index([isPublished, language])
  @@map("recipe")
}

enum Category {
  APPETIZER
  SOUP
  SALAD
  MAIN_COURSE
  SIDE_DISH
  DESSERT
  BEVERAGE
  BREAKFAST
  BRUNCH
  LUNCH
  DINNER
  SNACK
  BAKED_GOOD
  SAUCE
  CONDIMENT
  SPECIAL
}

model Ingredient {
  id                   Int                    @id @default(autoincrement())
  name                 String                 @unique
  category             String
  price                Float
  density              Float?
  // ediablePortion    Float?
  // asPerchase        Float?
  recipeIngredients    RecipeIngredient[]
  inventoryItems       InventoryItem[]
  orderItems           OrderItem[]
  vendors              Vendor[]
  //  position          Int?
  // embedding         Unsupported("vector(1024)")?
  WasteRecords         WasteRecord[]
  IngredientAllergens  IngredientAllergen[]
  priceHistory         SupplierPriceHistory[]
  DietaryRestrictions  DietaryRestriction[]
  dietaryRestrictionId Int?
  // Nutritional information per 100g/ml
  calories             Float?
  protein              Float?
  carbohydrates        Float?
  fat                  Float?
  fiber                Float?
  sugar                Float?
  sodium               Float?
  // Reference to external database
  usdaFoodId           String?
  // Track source of nutritional data
  nutritionSource      NutritionSource?       @default(MANUAL)
  // Last updated timestamp for nutritional values
  nutritionUpdatedAt   DateTime?
  // ...

  //@@index([position])
  @@map("ingredient")
}

// Optimize RecipeIngredient with better constraints
model RecipeIngredient {
  id                     Int      @id @default(autoincrement())
  recipeId               Int
  ingredientId           Int
  quantity               Float
  unit                   String
  processingInstructions String?
  substituteIngredients  Int[]
  isOptional             Boolean  @default(false)
  notes                  String?
  cost                   Float?
  density                Float?
  yield                  Float?
  joinAt                 DateTime @default(now())
  recipeVersionId        Int?

  // Relationships
  recipe        Recipe         @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredient    Ingredient     @relation(fields: [ingredientId], references: [id], onDelete: Restrict)
  recipeVersion RecipeVersion? @relation(fields: [recipeVersionId], references: [id], onDelete: SetNull)

  // Constraints

  @@unique([recipeId, recipeVersionId])
  @@unique([recipeId, ingredientId])
  @@index([recipeVersionId])
  //  @@check(quantity > 0)
  @@map("recipeIngredient")
}

model RecipeInstruction {
  id              Int               @id @default(autoincrement())
  recipeId        Int
  recipe          Recipe            @relation(fields: [recipeId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  stepNumber      Int
  instruction     String
  imageUrl        String?
  RecipeVersion   RecipeVersion?    @relation(fields: [recipeVersionId], references: [id], onDelete: Cascade)
  recipeVersionId Int?
  timeInMinutes   Int?
  temperature     Float?
  temperatureUnit String?           @default("C")
  isCritical      Boolean           @default(false)
  techniqueTips   String?
  warningNotes    String?
  equipment       RecipeEquipment[]

  @@unique([recipeId, stepNumber, recipeVersionId])
  @@map("recipeInstruction")
}

// Enhanced InventoryItem with better tracking
model InventoryItem {
  id               Int       @id @default(autoincrement())
  inventoryId      Int
  ingredientId     Int
  quantity         Float
  unit             String
  minQuantity      Float
  restockThreshold Float
  lastCountDate    DateTime?
  lastOrderDate    DateTime?
  lastUpdatedById  Int?
  lastUpdated      DateTime  @updatedAt
  par              Float // Par level for automatic reordering
  reorderPoint     Float // Point at which to trigger reorder
  maxQuantity      Float? // Maximum storage capacity
  location         String? // Storage location within inventory
  barcode          String? // For scanning support
  notes            String?

  // Price tracking
  currentPrice      Float
  averageCost       Float // Moving average cost
  lastPurchasePrice Float?

  // Relationships
  inventory     Inventory              @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  ingredient    Ingredient             @relation(fields: [ingredientId], references: [id], onDelete: Restrict)
  lastUpdatedBy User?                  @relation("InventoryItemUpdater", fields: [lastUpdatedById], references: [id], onDelete: SetNull)
  transactions  InventoryTransaction[]
  withdrawals   InventoryWithdrawal[]
  stockCounts   StockCountItem[]
  //  @@check(quantity >= 0)
  // @@check(minQuantity >= 0)
  //   @@check(restockThreshold >= minQuantity)
  //@@check(currentPrice >= 0)

  // Constraints and indexes
  @@unique([inventoryId, ingredientId])
  @@index([ingredientId])
  @@index([lastCountDate])
  @@map("inventory_item")
}

// New model for tracking inventory transactions
model InventoryTransaction {
  id          Int             @id @default(autoincrement())
  inventoryId Int
  itemId      Int
  type        TransactionType
  quantity    Float
  unit        String
  previousQty Float
  newQty      Float
  cost        Float?
  reference   String? // PO number, Invoice number, etc.
  notes       String?
  createdById Int
  createdAt   DateTime        @default(now())

  // Relationships
  inventory Inventory     @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  item      InventoryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  createdBy User          @relation(fields: [createdById], references: [id], onDelete: Restrict)

  @@index([inventoryId, type, createdAt])
  @@index([itemId, createdAt])
  @@map("inventory_transaction")
}

// New model for physical inventory counts
model StockCount {
  id          Int         @id @default(autoincrement())
  inventoryId Int
  status      CountStatus
  startedAt   DateTime
  completedAt DateTime?
  createdById Int
  notes       String?

  // Relationships
  inventory Inventory        @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  createdBy User             @relation(fields: [createdById], references: [id], onDelete: Restrict)
  items     StockCountItem[]

  @@index([inventoryId, status])
  @@map("stock_count")
}

model StockCountItem {
  id           Int     @id @default(autoincrement())
  stockCountId Int
  itemId       Int
  expectedQty  Float
  actualQty    Float
  difference   Float
  notes        String?

  // Relationships
  stockCount StockCount    @relation(fields: [stockCountId], references: [id], onDelete: Cascade)
  item       InventoryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([stockCountId, itemId])
  @@map("stock_count_item")
}

// New enums for inventory management
enum InventoryType {
  MAIN
  BAR
  PREP
  STORAGE
  WALK_IN
  FREEZER
}

enum TransactionType {
  PURCHASE
  WITHDRAWAL
  ADJUSTMENT
  WASTE
  TRANSFER_IN
  TRANSFER_OUT
  COUNT_ADJUSTMENT
  PRODUCTION
  RETURN
}

enum CountStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Add useful computed fields for Recipe
model RecipeStats {
  id               Int       @id @default(autoincrement())
  recipeId         Int       @unique
  totalCost        Float
  profitMargin     Float
  averageRating    Float
  preparationCount Int
  lastPrepared     DateTime?

  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  @@map("recipe_stats")
}

model Order {
  id           Int         @id @default(autoincrement())
  restaurantId Int
  restaurant   Restaurant  @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  vendorId     Int
  vendor       Vendor      @relation(fields: [vendorId], references: [id], onDelete: Restrict)
  status       OrderStatus
  items        OrderItem[]
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  @@map("order")
}

model OrderItem {
  id           Int        @id @default(autoincrement())
  orderId      Int
  order        Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  ingredientId Int
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Restrict)
  quantity     Float
  unit         String
  price        Float

  @@map("orderItem")
}

model Vendor {
  id                   Int                    @id @default(autoincrement())
  name                 String                 @unique
  contact              String
  email                String                 @unique
  phone                String
  orders               Order[]
  ingredients          Ingredient[]
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  supplierPriceHistory SupplierPriceHistory[]

  @@map("vendor")
}

model Shift {
  id        Int         @id @default(autoincrement())
  userId    Int
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  startTime DateTime
  endTime   DateTime
  status    ShiftStatus
  tasks     ShiftTask[]

  @@map("shift")
}

model PrepBoard {
  id        Int        @id @default(autoincrement())
  name      String
  status    PrepStatus
  recipes   Recipe[]
  prepItems PrepItem[] @relation("PrepBoardToPrepItems")
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@map("prepBoard")
}

model PrepItem {
  id           Int        @id @default(autoincrement())
  prepBoardId  Int
  prepBoard    PrepBoard  @relation("PrepBoardToPrepItems", fields: [prepBoardId], references: [id], onDelete: Cascade)
  recipeId     Int
  recipe       Recipe     @relation(fields: [recipeId], references: [id], onDelete: Restrict)
  quantity     Int
  status       PrepStatus
  assignedToId Int
  assignedTo   User       @relation(fields: [assignedToId], references: [id], onDelete: Restrict)

  @@map("prepItem")
}

model PasswordReset {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("passwordReset")
}

model Menu {
  id           Int            @id @default(autoincrement())
  name         String
  restaurantId Int
  restaurant   Restaurant     @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  menuItems    MenuItem[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  MenuCategory MenuCategory[]

  @@map("menu")
}

model MenuItemRecipe {
  id         Int      @id @default(autoincrement())
  menuItemId Int
  menuItem   MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  recipeId   Int
  recipe     Recipe   @relation(fields: [recipeId], references: [id], onDelete: Restrict)
  joinAt     DateTime @default(now())

  @@unique([menuItemId, recipeId])
  @@map("menuItemRecipe")
}

// Improve MenuItem relationships
model MenuItem {
  id                   Int      @id @default(autoincrement())
  name                 String
  description          String?
  price                Float
  foodCost             Float
  isActive             Boolean  @default(true)
  recipeIds            Int[]
  recipeServingsAmount Float[]
  recipeServingsCost   Float[]
  allergens            String[] // Array of allergen names for quick lookup
  menuId               Int
  categoryId           Int?

  // Relationships with proper cascading
  menu                Menu                        @relation(fields: [menuId], references: [id], onDelete: Cascade)
  category            MenuCategory?               @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  recipes             Recipe[]
  menuItemRecipes     MenuItemRecipe[]
  nutritionalInfo     NutritionalInfo?
  recommendations     NutritionalRecommendation[]
  salesTransactions   SalesTransactions[]
  leftoverItems       LeftoverItem[]
  feedback            CustomerFeedback[]
  dietaryRestrictions DietaryRestriction[]

  // Improved indexing
  @@index([menuId, isActive])
  @@index([categoryId])
  @@index([name])
  //  @@check(price >= foodCost)
  @@map("menuItem")
}

model NutritionalInfo {
  id            Int       @id @default(autoincrement())
  menuItemId    Int?      @unique
  menuItem      MenuItem? @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  calories      Float
  fat           Float
  saturatedFat  Float
  transFat      Float
  cholesterol   Float
  sodium        Float
  carbohydrates Float
  fiber         Float
  sugar         Float
  protein       Float
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("nutritionalInfo")
}

model FoodCostHistory {
  id        Int      @id @default(autoincrement())
  recipeId  Int
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  cost      Float
  date      DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("foodCostHistory")
}

model PrepHistory {
  id        Int      @id @default(autoincrement())
  recipeId  Int
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  quantity  Int
  date      DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("prepHistory")
}

enum UserRole {
  ADMIN
  MANAGER
  CHEF
  STAFF
  VENDOR
}

enum OrderStatus {
  PENDING
  APPROVED
  ORDERED
  RECEIVED
  CANCELLED
}

enum ShiftStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
}

enum PrepStatus {
  COMPLETED
  CANCELLED
  MISSING_ITEM
  PENDING
  ON_PROGRESS
  POSTPONE
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum PhotoType {
  MAIN
  STEP
  PLATING
  TECHNIQUE
  EQUIPMENT_SETUP
}

enum NutritionSource {
  MANUAL // Entered manually by user
  USDA // From USDA database
  CUSTOM // Custom entry but verified
  ESTIMATED // Calculated based on similar ingredients
}
